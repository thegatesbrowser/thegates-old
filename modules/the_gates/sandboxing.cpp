#include "sandboxing.h"

#ifdef _WIN32
#include "Windows.h"
#else
#include <seccomp.h>
#include <sys/prctl.h>
#endif

void Sandboxing::_bind_methods() {
	// ClassDB::bind_method(D_METHOD("create", "format", "view"), &ExternalTexture::_create, DEFVAL(Array()));
}

#ifdef _WIN32
Error Sandboxing::sandbox() {
	HANDLE process_token;
	HANDLE restricted_token;

	bool success = OpenProcessToken(GetCurrentProcess(), TOKEN_DUPLICATE, &process_token);
	ERR_FAIL_COND_V_MSG(!success, ERR_CANT_OPEN, "Unable to OpenProcessToken. Error code: " + itos(GetLastError()));
	
	success = CreateRestrictedToken(process_token, DISABLE_MAX_PRIVILEGE, 0, NULL, 0, NULL, 0, NULL, &restricted_token);
	ERR_FAIL_COND_V_MSG(!success, ERR_CANT_CREATE, "Unable to CreateRestrictedToken. Error code: " + itos(GetLastError()));

	return OK;
}

#else
Error Sandboxing::sandbox() {
	// While just banning dangerous syscalls could be much better for mantaining this library, I don't trust that I would be able to comprehensively list them
	// This list was generated by looking at the emitted syscalls from godot

	// Maybe would could limit this more? Surely some of these are used but not absoloutely required.
	const char *permitted_syscalls[] = {
		"access",
		"arch_prctl",
		"brk",
		"chdir",
		"clock_gettime",
		"clock_nanosleep",
		"clone3",
		"close",
		"connect",
		"execve",
		"exit_group",
		"fadvise64",
		"fcntl",
		"fstat",
		"fstatfs",
		"ftruncate",
		"futex",
		"getcwd",
		"getdents64",
		"getegid",
		"geteuid",
		"getgid",
		"getpeername",
		"getpid",
		"getrandom",
		"getresgid",
		"getresuid",
		"getsockname",
		"getsockopt",
		"gettid",
		"getuid",
		"ioctl",
		"lseek",
		"lstat",
		"memfd_create",
		"mkdir",
		"mmap",
		"mprotect",
		"mremap",
		"munmap",
		"newfstatat",
		"openat",
		"pipe2",
		"poll",
		"ppoll",
		"prctl",
		"pread64",
		"prlimit64",
		"read",
		"readlink",
		"recvfrom",
		"recvmsg",
		"rmdir",
		"rseq",
		"rt_sigaction",
		"rt_sigprocmask",
		"sched_getaffinity",
		"sched_get_priority_max",
		"sched_get_priority_min",
		"sched_setaffinity",
		"sched_yield",
		"sendmsg",
		"sendto",
		"set_robust_list",
		"setsockopt",
		"set_tid_address",
		"socket",
		"socketpair",
		"stat",
		"statfs",
		"symlink",
		"sysinfo",
		"umask",
		"uname",
		"unlink",
		"vfork",
		"wait4",
		"write",
		"writev",
	};

	// Block ALL syscalls, we will punch holes in this.
	// ERRNO 1 seems to allow the process to continue, even if the syscall fails.

	// uint action = SCMP_ACT_LOG;
	// uint action = SCMP_ACT_ERRNO(1);
	uint action = SCMP_ACT_KILL;
	// uint action = SCMP_ACT_TRAP;

	scmp_filter_ctx seccomp_ctx = seccomp_init(action);
	ERR_FAIL_COND_V_MSG(!seccomp_ctx, ERR_CANT_CREATE, "Unable to initialize seccomp");

	// Punch holes for every syscall we need.
	for (int i = 0;
		 i < sizeof(permitted_syscalls) / sizeof(permitted_syscalls[0]); i++)
	{
		const char *syscall = permitted_syscalls[i];
		int err = seccomp_rule_add_exact(seccomp_ctx, SCMP_ACT_ALLOW, seccomp_syscall_resolve_name(syscall), 0);
		ERR_FAIL_COND_V_MSG(err, FAILED, "Unable to seccomp rule add " + String(syscall));
	}

	/* apply the composed filter */
	int err = seccomp_load(seccomp_ctx);
	ERR_FAIL_COND_V_MSG(err, FAILED, "Unable to seccomp load");

	/* release allocated context */
	seccomp_release(seccomp_ctx);

	err = prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);
	ERR_FAIL_COND_V_MSG(err == -1, FAILED, "Unable to prctl PR_SET_NO_NEW_PRIVS");

	return OK;
}
#endif

Sandboxing::Sandboxing() {
}

Sandboxing::~Sandboxing() {
}
